# -*- mode: org; mode: auto-fill -*-

# by default don't subscript a_b. a_{b} is still subscripted
#+OPTIONS: ^:{}

#+TITLE: Oblong's build/distribution system

* General overview

This is a set of =Makefiles= designed to provide build and deployment
infrastructure for various software projects being developed at Oblong
Industries. This infrastructure is used every time a developer run =make=, every
time a package maintainer types =dpkg-buildpackage= and every time a user
installs the resulting package.

It is important to note that this build system is *not a replacement for make*.
Instead, it uses =make= to set up a code repository to allow for efficient
builds and consistent, organized packages.

** Motivation and target use cases

This was designed to fit the development practices used at Oblong. These include

- The code being built has some libraries, some tools and some daemons. Many
  things can have configuration files and resources that need to be shipped
- Debian-based OS
- Daemons to be built should be managed by upstart
- Repositories organized into sub-projects, many of which depend on each other
- The bulk of the code is in C or C++. Lots of it is broken-out into libraries,
  but still lives in the same repository

Design goals and design decisions:

- *The code should be as simple and fast as possible*. Thus everything written in
  plain GNU Make. No autotools. At build-time the =Makefiles= should be as
  self-contained as possible. Build-time calls to external tools should be kept
  at a minimum =awk= or =sed= calls are OK, but nothing that invokes an
  interpreter, such as =perl=. At package-building time =perl= is OK, since this
  happens much more rarely than plain builds.
- It should be possible to check out the code and run a =make= to do a build or
  a =dpkg-buildpackage= to build packages with no extra steps under "normal"
  conditions. Missing build dependencies are deemed an "abnormal" condition, and
  these should be easily detected and satisfiable with simple
  =dpkg-checkbuilddeps= and =apt-get= calls.
- Each directory to be built in the repository is called a *project*. Each
  project's build and distribution is fully defined with a single =Makefile=
  that lives in the project's directory
- The =Makefile= defining the project should be simple and flexible. It should
  be possible to do normal "make" things in it, such as define new targets,
  rules, dependencies, etc.
- Common conventions and workflows should be assumed in order to simplify and to
  reduce boilerplate.
- Common uses should be very easy; intricate uses should be possible;
  unconventional and non-standard uses should be hard/impossible.
- Build happens non-recursively: each project Makefile is =include=-ed into one
  large instance of =make= instead of running many smaller instances. This
  speeds up build times, and allows fine-grained builds to run efficiently.
  Oft-cited treatise on the topic: http://aegis.sourceforge.net/auug97.pdf
- As much as possible, *dependencies should be computed automatically*. This
  applies to =#include= header dependencies, intra-repository project
  dependencies (to build dependent libraries in same repo), and package
  install-time dependencies.

  Header dependencies are generated by gcc. The build system keeps track of
  intra-repository library dependencies. Debian enforces library dependencies
  during both build and installation with =dh_shlibdeps=.

  The dependencies are meant to be very anally checked to make sure that a
  resulting package that can be installed will work.
- The definition of debian packages that a repository can generate is
  integrated into the build. For each project the build system will require the
  corresponding packages to be defined in =debian/control=.
- All versioning information comes from =debian/changelog=. Most notably this
  applies to the ABI versions of the libraries being built.
- Library packages have versioned binary and =-dev= packages, so that the
  =-dev= packages can have multiple versions installed at a time
- It should be possible to run any executables built from the tree in-place,
  without needing to install or copy anything from the repository.

** Nomenclature

This project was written to support software development at Oblong Industries.
There's nothing here that's specific to Oblong, but this heritage is evident in
the names of some packages, paths, etc.

The build system project itself is called =oblong-buildsystem=. The current tree
makes sure that all packages being built are called =oblong-xxx= or
=liboblong-xxx=. It also sends package contents to =/etc/init/oblong= for
upstart configurations, =/etc/oblong= for general configuration,
=/var/log/oblong= for logs and =/usr/share/oblong= for general resources. This
is not adjustable at this time, but the user can easily do this. Furthermore,
this project is released under a permissive license, so it is allowed to modify
"oblong" to something else.

** Starting a new project

There is sadly some boilerplate associated with the initial setup of the
=Makefiles= and the debianization. It is thus recommended to copy the =sample=
project shipped with the build system (packaged in
=/usr/share/doc/oblong-buildsystem1/examples=), and to use it as a template
starting point.

* How to build

Fundamentally, a =make= at the top level builds everything. A =make= in a
project subdirectory builds that project and any dependencies.

/All/ the builds actually happen in the root of the project tree, even if a
=make= is issued in a subdirectory. All the build commands are printed out as
they are executed. To repeat a specific command, it can simply be pasted into
the terminal, /when in the root directory/.

** Source tree layout
A sample tree that uses this build system is in the =sample= directory
(available in =/usr/share/doc/oblong-buildsystemN/examples= if the build system
package is installed). To start a new repository based on this build system, the
sample can be copied and treated as a template.

The source tree is organized into *projects*, each of which lives in a directory
beneath the repository root, and has a =Makefile= defining the project's
contents. Note that /a project's location does not include its subdirectories/.
So as an example, =libAAA= and =libAAA/apps= are separate projects.

Unit tests for a project =libAAA= are assumed to live in the =libAAA= directory
itself, or in =libAAA/tests=. If =libAAA/tests= exists, it will be used. This is
the only special rule for tree layout.

The build system itself is installed in the =oblong-buildsystemN= package, where
=N= is the interface version of the build system. In order for a repository to
use the build system, the top level of the tree should have a =buildsystem=
symlink to =/usr/share/oblong/buildsystemN/=. It should also have a toplevel
=Makefile= symlink to =buildsystem/Makefile=. Two build-system-related Makefiles
must appear in the toplevel of the repo:

| =Makefile.sys=         | various system-specific variable definitions |
| =Makefile.projectdefs= | defines projects and subsets                 |

A =Makefile.sys= can contain flags to apply to this whole project. For instance:

#+BEGIN_EXAMPLE
CC        := gcc-4.7
CXX       := g++-4.7

CCXXFLAGS += -Werror -Wall

CCXXFLAGS += -I/usr/include/repo1
LDFLAGS   += -L/usr/lib/repo1
#+END_EXAMPLE

=Makefile.projectdefs= must list all the directories that contain
projects to build (in the =DIRS= variable). It can also define subsets,
as described in [[Subsets]].

The Makefiles in the build system itself are not meant to be
user-editable, but for completeness, these are:

| =Makefile=             | main top-level Makefile                           |
| =Makefile.header=      | included at the start of every project =Makefile= |
| =Makefile.footer=      | included at the end of every project =Makefile=   |
| =Makefile.defs=        | various definitions used by the other =Makefile=  |
| =Makefile.install=     | =make install= rules used for package-making      |
| =Makefile.qt=          | special rules for projects using QT               |

** Build dependencies
Fundamentally, the new directory tree is a plain debian tree, so you can check
out the source and immediately run all the various debian tools that work with
package source trees. The =debian= directory lives with the rest of the source,
so debian-native packages are built.

The new system leans heavily on Debian to make sure all the necessary
build-dependencies are satisfied. A Debian tool to check this is
=dpkg-checkbuilddeps=. If this tool does not complain of any missing packages,
then a =make= should succeed. If it doesn't, then the tree has a bug that should
be fixed.

*** User-customized variables
Without =dpkg-checkbuilddeps= reporting all the dependencies being satisfied,
debian will /refuse/ to build packages. However, it is still possible to build
and run the code, provided the dependencies for the pieces you're building exist
on the machine in some form. A library in a nonstandard location can be used by
giving =make= custom linker and compiler flags. So, for instance, to build with
=libfoo= that lives in =/tmp/libfoo= run make like

#+BEGIN_EXAMPLE
$ LDFLAGS=-L/tmp/libfoo CXXFLAGS=-I/tmp/libfoo make
#+END_EXAMPLE

Any variable not otherwise used by the build system can be customized in this
manner.

** Targets
To build the whole tree after checking it out, simply issue

#+BEGIN_EXAMPLE
$ make
#+END_EXAMPLE

It is not required to build the whole tree, if only a part is needed. For
instance, to build the =libAAA= project, do any of

#+BEGIN_EXAMPLE
$ make libAAA

$ make libAAA/all

$ cd libAAA
$ make
#+END_EXAMPLE

It is similarly possible to build specific files. So to build just one
executable in =libAAA=, do something like

#+BEGIN_EXAMPLE
$ make libAAA/someobject.o
#+END_EXAMPLE

Note that for all of these it is /not/ necessary to have built the tree first.
=make= knows exactly what needs to be built in which order, even if it's other
projects in this repository.

If a target isn't specified, a special target =all= is built. In the root of the
repository, =all= will build everything, while in a particular project =all=
builds everything /for that project/. Similarly, the =clean= rule will clean out
the whole repository if you =make clean= in the root, and will clean out just
=libAAA= if you =make libAAA/clean=. Similarly still, unit tests are executed by
making =check= or =test= in the appropriate location.

There's a special target =subdirs= that builds all projects in directories
beneath a given one. As an example, =make libAAA= will build the =libAAA=
project /only/, but =make libAAA/subdirs= will build the =libAAA= project /and/
any projects in subdirectories beneath =libAAA=, such as =libAAA/apps=,
=libAAA/apps/app1=, etc.

Note that while there exists an =install= target, it's meant solely for the
debian packager and /not/ for the user. There is no general need to "install"
the code; simply run it in-place. If for some reason it /is/ desired to
"install" everything to a particular directory, the =localinstall= rule can be
used: =make localinstall= will build everything and copy it to the
=localinstall= subdirectory of the toplevel.

If any subsets are defined, they create special targets. See the [[Subsets]] section
for more information.

** Build variables
There are a number of variables in the build system, but only a small
number that can be set by the user on the commandline to control the
details of a build. These are

| =CFLAGS=       | Flags to pass to the C compiler              |
| =CXXFLAGS=     | Flags to pass to the C++ compiler            |
| =CCXXFLAGS=    | Flags to pass to both the C and C++ compiler |
| =ASFLAGS=      | Flags to pass to both the assembler          |
| =CPPFLAGS=     | Flags to pass to the preprocessor            |
| =LDFLAGS=      | Flags to pass to the linker                  |

These variables are defined in the [[file:../Makefiles/Makefile.defs::ACTIVE_VARS_CUSTOMIZABLE%20:%3D%20CCXXFLAGS%20CFLAGS%20CXXFLAGS%20LDFLAGS][=ACTIVE_VARS_CUSTOMIZABLE=]] variable
in =Makefile.defs=.

For instance, to build a project with profiling information for =gprof=, issue

#+BEGIN_EXAMPLE
$ CCXXFLAGS=-pg LDFLAGS=-pg make
#+END_EXAMPLE

Note that since plain =make= is actually doing the build, there's no
intelligence built-in to detect that the flags have changed and to trigger the
rebuild. So it is the user's responsibility to clean out the parts of the tree
that the user wants to rebuild with the new flags.

To build without optimization, issue

#+BEGIN_EXAMPLE
$ CCXXFLAGS=-O0 make
#+END_EXAMPLE

Optimization is handled specially. By default =-O2= is used. If some
other =-O= setting is specified somewhere (on the commandline or in any
of the Makefiles), then it takes precedence, replacing the default
=-O2=.

* How to write =Makefiles=
** Example
As mentioned previously, each project is defined by a =Makefile= appearing in
the project's directory. Example =Makefiles= from the =sample= project: 

#+BEGIN_EXAMPLE
# libAAA/Makefile

ROOT ?= ..
include $(ROOT)/buildsystem/Makefile.header

LIB_OBJECTS  = aaa.o
DIST_HEADERS = *.h

include $(ROOT)/buildsystem/Makefile.footer
#+END_EXAMPLE

#+BEGIN_EXAMPLE
# frobnicator/Makefile

ROOT ?= ..
include $(ROOT)/buildsystem/Makefile.header

TARGET_NAME := dofrobnicate

CCXXFLAGS += -I$(ROOT)

BIN_TARGET = dofrobnicate
LDLIBS += ../libAAA/libAAA.so

DAEMON_COMMAND = dofrobnicate --thusly

define UPSTART_STANZAS
start on start-frobnicating-signal
endef

include $(ROOT)/buildsystem/Makefile.footer
#+END_EXAMPLE

This is fairly typical. Every =Makefile= has just 3 lines of boilerplate: the
first 2 and the last line of this example. The =ROOT= variable must be
conditionally defined to point to the root of the repository from this
directory, as shown here. The two =include= lines must be as they are here.

The rest of the =Makefile= defines the project. Even though the build happens in
the root directory of the repository, the project =Makefiles= such as this are
written relative to the /project/ directory. For this reason the above
=Makefile= just lists out files without giving any paths. As described in
[[Arbitrary =make= expressions]], this path-agnosticism is only possible with simple
=Makefiles= that stay within the bounds of the build system's express
intentions; some things /do/ require paths.

The =LIB_OBJECTS= variable lists our all the objects that are meant to go into
the library being built.

The =DIST_HEADERS= variable indicates which headers in a library should be
distributed into the =-dev= package. Here we distribute all of them. Note that
the build system handles the wildcard here; plain make does not do this.

The =TARGET_NAME= overrides the name of this project, which controls the name of
the package being generated. By default the project name comes from the name of
the directory.

The =CCXXFLAGS= are the flags that are passed to the C and C++ compilers for
/all/ the compiles that happen in this project. The variables =ROOT= and =dir=
are used to reference the root of the repository and the project directory
respectively. So to add the tree root directory to the header search path, use
=-I$(ROOT)=.

The =BIN_TARGET= and =BIN_TARGET_NOINST= variables hold all the binaries that
are to be built for this project. The former will /also/ be installed into the
package. These executables will automatically link with the corresponding object
file, this project library (if any =LIB_OBJECTS= are given) and any =LDLIBS=. So
here =dofrobnicate= will automatically link with =dofrobnicate.o= and with
=libAAA.so=, both of which the build system will build.

The =LDLIBS= are the libraries this library links with. This applies to the
shared object and all executables built by the project. Any =.so= library given
as a path (without =-l=) is evaluated to see whether it lies inside this same
repository. If it does, a dependency on that library is added. So in this case
=libAAA= will be built before anything in =frobnicator/Makefile= is linked.

This project contains a daemon that is intended to run once installed. This
daemon is to be controlled by Upstart, once installed. The =DAEMON_COMMAND= is
the command to launch the daemon. =UPSTART_STANZAS= is any extra stanzas to
place into the upstart definition. Details are in [[Distribution details]].

** Adding a new project to an existing repository

To make a new project you have to do 3 things:

1. Write the project =Makefile=
2. Add the project to the =DIRS= variable in =Makefile.projectdefs=
3. Add the project package descriptions to =debian/control=

The =Makefile= and various variables are described below. Details
regarding packaging definitions are found below in [[Debian packages]].

** Variables
*** Project list
The build system needs a list of all the projects it is responsible for. This is
given in the =DIRS= variable in =Makefile.projectdefs=. This is simply a
whitespace-separated list of all the directories that contain relevant
=Makefiles=. No particular ordering is required in this list.

*** Subsets
The build system is thorough in its handling of build dependencies, so it is not
required to do a toplevel =make= if you are working on a particular project. As
stated in [[Targets]], you can =make libAAA= to make the libAAA project /and/ all of
its dependencies. Additionally, you can =make libAAA/subdirs= to build the above
/and/ any projects in =libAAA='s subdirectories /and/ their dependencies.

At times, these auto-generated subsets of the tree are not sufficient. One can
want specific named subsets of the tree. This is achieved by defining a variable
named =xxx_SUBSET= where =xxx= is the name of the subset being defined. This can
be defined either globally in =Makefile.projectdefs= or in any project
=Makefile=. As you would expect, subset definitions in =Makefile.projectdefs=
take project directories referenced from the repository root, while those
defined in project =Makefiles= are referenced from that project's directory.

If =xxx_SUBSET= is defined in =libAAA=, it can be built by a =make xxx= or =make
libAAA/xxx=; it can be cleaned out by =make xxx/clean= or =make
libAAA/xxx/clean=. If =xxx_SUBSET= is defined at the top level, only =make xxx=
and =make xxx/clean= work, as would be expected. Note that these are the /only/
paths that would work. So =make libBBB/xxx= would try to build a file called
=libBBB/xxx= instead of invoking the subset.

An example subset definition:

#+BEGIN_EXAMPLE
aaa_SUBSET := libAAA/apps/app1 libAAA/apps/app2 tools/eval_aaa
#+END_EXAMPLE

*** Build system state
When a project =Makefile= is parsed, =$(dir)= is a path to the current
project directory and =$(ROOT)= is a path to to the root of the
repository. These are mostly needed for [[Arbitrary =make= expressions]];
i.e. parts of the =Makefile= that are not automatically re-pathed by the
build system.

*** Build flags
To control the way a particular project is built, the following variables are
available:

| =CC=        | C compiler. =gcc= by default                 |
| =CXX=       | C++ compiler. =g++= by default               |
| =CC_LINKER= | Linker command. =$(CC)= by default           |
| =CFLAGS=    | Flags to pass to the C compiler              |
| =CXXFLAGS=  | Flags to pass to the C++ compiler            |
| =CCXXFLAGS= | Flags to pass to both the C and C++ compiler |
| =ASFLAGS=   | Flags to pass to the assembler               |
| =CPPFLAGS=  | Flags to pass to the preprocessor            |
| =LDFLAGS=   | Flags to pass to the linker                  |
| =LDLIBS=    | Libraries to link with                       |

If defined globally in the project =Makefile=, these variables apply to /all/
builds that happen in this project. If we want a variable to apply /only/ to a
particular part of the project, we can set it as a per-target variable. So as an
example

#+BEGIN_EXAMPLE
$(dir)/test.o: CCXXFLAGS += -foo
$(dir)/app:    LDLIBS += -lbar
#+END_EXAMPLE

would build =test.o= with all the flags it normally gets /and/ also =-foo=.
Likewise, =app= would link with =-lbar= in addition to everything else. Note
that these rules go to Make directly, without any intervention by the build
system, so it is necessary to prefix the targets with =$(dir)=.

It is also important to note that these variables can be modified however one
likes; they are /not/ just append-only. By the time the project =Makefile= is
parsed, all the variables are already set to their default values (from
=Makefile.sys= and the commandline customizations). A project =Makefile= can
override these by setting =CCXXFLAGS= to whatever they like. For instance, one
can turn off the default =-Werror= behavior with

#+BEGIN_EXAMPLE
ALLOW_OVERRIDE := 1
CCXXFLAGS := $(filter-out -Werror,$(CCXXFLAGS))
#+END_EXAMPLE

This removes =-Werror= from the current value of =$(CCXXFLAGS)=. Here
=$(filter-out ....)= is a GNU Make function that is described in detail in its
manual. Modifications to these variables are project-local, so removing
=-Werror= in one =Makefile= does not affect it in any others. Note that if an
[[*Variable%20handling][active variable]] is modified in a way that's not strictly append-only, the user
/must/ also set =ALLOW_OVERRIDE=. This is a safety measure to prevent accidental
overwriting of variables.

=LDLIBS= defines the libraries that this project needs to link with. Any
libraries that appear here that live in this same repository /and end in/ =.so=
are automatically picked up as a dependency. In the [[Example]], we see =libAAA=
defined as a dependency of =dofrobnicate= by adding to the former's =Makefile=:

#+BEGIN_EXAMPLE
LDLIBS += ../libAAA/libAAA.so
#+END_EXAMPLE

Note that the library in =LDLIBS= /must/ be given as a =.so= for this to work.

*** Project definitions
There are a number of variables that define the project itself. These are

| =TARGET_NAME=       | name of project; the directory name if omitted         |
| =LIB_OBJECTS=       | all the objects to include in the library being built. |
| =BIN_TARGET=        | executables to build and distribute                    |
| =BIN_TARGET_NOINST= | executables to build but /not/ distribute              |
| =EXTRACLEAN=        | extra files that =make clean= should delete            |

=TARGET_NAME= affects the naming of packages that are generated from a project,
and the name of any libraries that are built. This comes from the directory
name, but the user can override this in the project =Makefile=.

If the project has a library, its =Makefile= lists the objects that comprise it
in the =LIB_OBJECTS= variable.

The =BIN_TARGET= and =BIN_TARGET_NOINST= variables list the executables that
this project builds. The former are installed into packages, the latter not. If
this project has a library (non-empty =LIB_OBJECTS=), each executable
automatically links with it. Also, each executable automatically compiles and
links a similarly-named source file. For example, to build
=frobnicator/dofrobnicate=, its project =Makefile= needs to say /only/

#+BEGIN_EXAMPLE
BIN_TARGET = dofrobnicate
#+END_EXAMPLE

The build system automatically links in =libAAA.so= /and/ =dofrobnicate.o=
(built from =dofrobnicate.c=). This is intended to reduce boilerplate for common
cases.

If an executable requires more than just the one source file, this can be
specified with a plain make dependency. For example if our =dofrobnicate= also
required =frobnicator/other.o=, this could be defined with the single line

#+BEGIN_EXAMPLE
$(dir)/dofrobnicate: $(dir)/other.o
#+END_EXAMPLE

Note that =$(dir)= is required here as well.

If the project builds any files outside of the build system itself, they must be
cleaned out with the =EXTRACLEAN= variable. This is used primarily with
[[Arbitrary =make= expressions]]. All files listed here (relative to the project
directory) are deleted during a =make clean=. For instance the test suite
[[file:../tests/libC/Makefile::ROOT%20?%3D%20..][=libC/Makefile=]] has the following

#+BEGIN_EXAMPLE
$(dir)/c.o: $(dir)/c.generated.h
$(dir)/c.generated.h:
	echo 'static int gen = 5;' > $@
EXTRACLEAN += c.generated.h
#+END_EXAMPLE

It states that one of the objects needs a generated header, and defines a rule
to generate it. These two statements go directly to Make, so we add this
generated header to the =EXTRACLEAN= list to clean it out when needed. Note
that using =EXTRACLEAN= is also required when specifying additional objects to
link into an executable. For instance [[file:../tests/libA/Makefile::$(dir)/utila:%20$(dir)/subdir/utila_helper.o][=libA/Makefile=]] has

#+BEGIN_EXAMPLE
$(dir)/utila: $(dir)/subdir/utila_helper.o
EXTRACLEAN += subdir/utila_helper.o
#+END_EXAMPLE

Here we indicate that in addition to =utila.o= we also want to link in
=$(dir)/subdir/utila_helper= when linking =($dir)/utila=. We told Make about
this directly, so we must also tell the buildsystem to clean this out.

*** Distribution variables
A number of variables define what gets installed into packages, and how. These
are enumerated in the [[file:../Makefiles/Makefile.defs::DIST_TYPES%20:%3D][=DIST_TYPES=]] variable in =Makefile.defs=. The variables
are

| =DIST_BINS=         | executables. Automatically includes =BIN_TARGET=            |
| =DIST_HEADERS=      | header files                                                |
| =DIST_MANS=         | man-pages. Any =*.pod= would fill this in automatically     |
| =DIST_DOCS=         | documentation. Any =*.pod= would fill this in automatically |
| =DIST_ETC_OBLONG=   | configuration files                                         |
| =DIST_SHARE_OBLONG= | miscellaneous data                                          |

These are all fairly self-explanatory. All these variables can include
wildcards. The wildcards are evaluated when the variable is used, so files that
are not available at =Makefile=-parsing time (i.e. they are built) will still be
found and installed.

Documentation written in a =*.pod= file is automatically converted to manpages
and =.html= and installed into the appropriate =DIST_...= variable. By contrast,
these =*.pod= wildcards are evaluated at parsing time, since all the =DIST_...=
variables describe files that /are generated/, while =*.pod= describe files that
/generate other files/.

There are several variables that describe the specifics of Upstart
configurations that are generated. These are

| =DAEMON_COMMAND=  | Command used to launch daemons                   |
| =UPSTART_STANZAS= | Any extra stanzas for the Upstart configurations |

By default, the path used to install the headers into the =-dev= packages is
inferred from the path of the project in the tree. If this is to be customized,
the =HEADER_PATH= variable can be used to override.

These are described in more detail in [[Distribution details]].

*** QT variables
To support projects using the QT library, a set of special rules has been
written. To make QT GUIs, QT wants to generate header files using its =uic=
utility, and to generate some source files using its =moc= utility. The build
system defines =$(QT4_UI_HEADERS)= to be a list of headers that QT wants to
generate, and =$(QT4_MOCS)= to be a list of =moc= objects that the compiler
would make from the generated sources. The result is that all the user has to do
is

#+BEGIN_EXAMPLE
$(dir)/app:   $(QT4_MOCS)
$(dir)/app.o: $(QT4_UI_HEADERS)
#+END_EXAMPLE

Here the application knows to link in the new extra objects and also to generate
the headers before trying to compile. The build system takes care of cleaning
these generated files when needed.

Note that certain naming conventions are assumed to generate these variables.
All =*.ui= files in the project directory are used to generate corresponding
=ui_*.h= files. Furthermore, all =*.h= files that contain the string "Q_OBJECT"
will generate corresponding =moc_*.cpp= files.

** Arbitrary =make= expressions
The project-defining =Makefiles= are plain GNU-make Makefiles. All functions,
expressions, etc. are available. As stated previously, any pieces of the
=Makefile= that stray from the capabilities provided directly by the build
system require special treatment in 2 ways:

1. files must be pathed with =$(dir)= for the project directory and
   =$(ROOT)= for the root of the repository
2. Any new targets must be added to =EXTRACLEAN=, so that they can be removed
   during a =make clean=

As an example, if I want to define a rule to build LaTeX documentation into a
pdf, install the result into a package when needed, and clean out the
intermediates when asked, I can say:

#+BEGIN_EXAMPLE
$(dir)/documentation.pdf: $(dir)/documentation.tex
	pdflatex -output-directory $(dir $@) $(@:.pdf=)
$(dir)/doc: $(dir)/documentation.pdf
.PHONY: $(dir)/doc

DIST_DOCS += documentation.pdf

EXTRACLEAN += $(addprefix documentation, .aux .log .out .pdf .toc)
#+END_EXAMPLE

This is mostly plain Make. The build system comes into play with the =DIST_DOCS=
variable to indicate that the pdf should be packaged as documentation, and with
the =EXTRACLEAN= variable to indicate the files that need to be cleaned out when
=make clean= is invoked.

** Version information in built applications

Sometimes it is desired for an application being built to know its own version
number (to reply to =--version= for instance). To address this, the build system
defines a preprocessor variable =_GIT_VERSION= as a string that contains the
output of =git describe --tags --always=.

** Compilation details

For sources that are going into a library (i.e. anything in =LIB_OBJECTS=) the
=-fPIC= option is passed in. This generates position-independent, relocatable
symbols required for shared libraries. A downside of the build system here is
that this option is used /even if statically-linked libraries are being built/.
This is inefficient because the relocatability incurs a performance penalty that
could be reclaimed when linking statically. This is due to the way =make=
handles per-target variables. I couldnd't find a nice way to get around this
isssue.

Prior to commit titled =All objects going into DSOs now built with -fPIC=, I was
using =-fPIC= only for shared objects. However, this was breaking per-target
variable settings. For instance, if a =Makefile= said

#+BEGIN_EXAMPLE    
    $(dir)/a.o: CCXXFLAGS += -Dasdf
#+END_EXAMPLE

then this would apply only to the no-fPIC version. The user would have to
specify the custom variable once more to apply to =-fPIC=. There are various
workarounds, such as to build it both ways every time, but that's probably more
trouble than its worth, so for now I simply live with this limitation.

** Linking details
By the very nature of the repository layout, there are some libraries in the
tree that are used by libraries/executables in other sections of the tree. This
creates a challenge where the other libraries/executables must be able to
reliably find the right copy of the underlying library. To solve this as
reliably as possible, the build links executables differently, depending on
whether they're being built for in-place execution (via a plain =make=), or for
packaged distribution (via any of debian's utilities).

When doing a plain build, any underlying in-tree libraries are always linked in
/statically/. Dynamic linking is only done when packages are built. For
example, suppose I have two projects in the tree: =libAAA= and =tool=. Suppose
=tool/Makefile= links against =libAAA= normally, by specifying

#+BEGIN_EXAMPLE
LDLIBS += ../libAAA/libAAA.so
#+END_EXAMPLE

During development-time builds, the executable =tool/tool= links statically
against =libAAA/libAAA.a=. During package-building time, this executable
dynamically links against =libAAA/libAAA.so= instead. This is done so that
during development the executables can be moved around and executed normally,
without worrying about where =libAAA= comes from. This also prevents potential
issues of the wrong copy of =libAAA= being picked up, if there's one already
installed into the system. Another way to have dealt with this is to always
dynamically link, but to set an RPATH for the in-tree case.

*** =RPATH=

When linking with a shared library, the library is searched at two distinct
points in time:

- At build-time: the linker searches for the library (given as a file on the
  linker commandline), resolves the symbols, adds the =SONAME= to the
  =DT_NEEDED= tag, etc. Search path: the standard locations + whatever is given
  in =-L=.
- At run-time: when running the linked application, the linker needs to load the
  library. It searches for the library (by the =SONAME=) in the =DT_NEEDED= tag.
  Search path: the standard locations + whatever is given in the =RPATH=.

The build system thus has a choice about how to set the =RPATH= of the
libraries, executables that it builds. The logic is:

- For any =-L= directory that does not start with =/usr/lib=, a corresponding
  =RPATH= is generated
- If we then build a package that contains this =RPATH=-ed binary, a loud
  warning is generated, since packages with =RPATH= are frowned-upon. Maybe this
  should even be a fatal error.

Note that there's a question here about what happens when we link with a library
in a generic subdirectory of =/usr/lib=, for instance =/usr/lib/repo1=. The
build system does /not/ make an =RPATH= but the library is still in a
non-standard path. In this scenario, it is assumed that the library employs the
common file arrangement described in [[Library install paths]]. I.e. given the
linker command

#+BEGIN_EXAMPLE
$ gcc -L/usr/lib/repo1 -lAAA ....
#+END_EXAMPLE

The build-time linker would find =/usr/lib/repo1/libAAA.so=, which lives in its
=-dev= package, and is a symlink to =/usr/lib/libAAA.so.ABI.REV=, which in turn
lives in the main library binary package. The =SONAME= of this library is
=libAAA.so.ABI=. This =SONAME= is stored in the binary being built. Thus at
run-time the linker would look in =/usr/lib= for =libAAA.so.ABI=. This should
exist as a symlink back to that same =/usr/lib/libAAA.so.ABI.REV=. This symlink
should also live in the main library binary package. This is the standard file
arrangement. The build system produces it, and expects the libraries it uses to
follow it as well.

* Debian packages
The build system was designed to lean heavily on Debian to manage dependencies
and to provide distribution tools. The system is designed to automatically set
up building of Debian packages. It is in fact impossible to define a project
without the ability to package itself. Furthermore, debhelper is used as much as
possible during the package build, so package dependencies are computed
automatically and reliably. Furthermore still, the build system is very anal
abount generated packages being reliable. Thus if there are any =-L= link flags
anywhere or if any non-packaged library is linked in, the packaging with fail
loudly (in the build system in the former case, and in =dpkg-shlibdeps= in the
latter).

** Package types
Each library generates 3 different packages:
1. =liboblong-xxxABI=
2. =liboblong-xxxABI-dev=
3. =liboblong-xxxABI-dbg= (handled by =debian/rules=, not the build system)

Each non-library generates 2 different ones:
1. =oblong-xxx=
2. =oblong-xxx-dbg= (handled by =debian/rules=, not the build system)

Here "=xxx=" is the =$(TARGET_NAME)=, appropriately debianized (all lowercase,
dashes instead of camelcase, etc). "=ABI=" is the ABI version (see [[Versioning]]
below).

By convention, the =lib...ABI= package contains =lib....so.ABI.REV= and
=lib....so.ABI= as a symlink to the former. =ABI= is the ABI version and =REV= is
the minor revision version. This shared object has an SONAME tag of
=lib....so.ABI=. The =lib...-dev= package contains =*.h=, =lib*.a= and =lib*.so=,
which is also a symlink. This is the standard way Debian organizes libraries.

Whether a package is a library or not is determined by the [[*Project%20definitions][=TARGET_NAME=]]. If
there is any ambiguity about whether a package is a library or not, the build
system will throw an error.

*** Debug symbols

All compilation happens with debug-info-generation enabled (=-g= flag). Before
moving a file into a package, the "usual" =debian/rules= entries strip out the
debug information into a separate package. This is done to not balloon the
package sizes needlessly, while still allowing the user to have debug symbols,
if requested.

The build system doesn't control =debian/rules=, so it can't enforce how the
=-dbg= packages are populated. It does however check =debian/control= to make
sure that each library at least has a =-dbg= package defined.

The stock =dh_strip= doesn't work here since it doesn't know how to deal with
multiple =-dbg= packages in the same repository. I usually use the following:

#+BEGIN_EXAMPLE
# find all the ...-dbg packages, and use dh_strip to separate out their debug
# symbols into the debug package. dh_strip should really be doing this itself
override_dh_strip:
	perl -ne 'print "$$1\n" if /^Package:\s*(\S+)-dbg/' debian/control | xargs -n1 -I{} dh_strip -p{} --dbg-package={}-dbg
#+END_EXAMPLE

This finds all the =-dbg= packages and runs =dh_strip= individually for each
one.

** Building packages
The tree is a plain debian source tree, so no special workflows are needed here.
I usually use =git-dch= to add entries to =debian/changelog= and
=git-buildpackage= to actually build the packages, but any other Debian tool
works just as well.

** Package and library versioning
The debian packaging is a fundamental part of the build system, so the =debian/=
directory lives together with the source in our source repository. This means
that we generate *native* Debian packages. Thus package version numbers do not
have dashes.

ABI versions of /all/ libraries in the repository are locked together. These all
come from the latest version number in =debian/changelog= (on the first line of
that file). This version is parsed as =a.b.c.d.e= with as many dot-separated
numbers as available. All but the last number are used as the ABI version, with
just the last number providing a revision counter; thus in that example
=a.b.c.d= is the ABI version and =e= is the revision. Thus at least two numbers
are required in the =debian/changelog= version.

As mentioned in [[Package types]], the ABI version is a part of the package names.
The packages are defined in =debian/control=, so the build system has no control
over what the packages are called. It will however make sure that the ABI
versions in the package names match the ABI version parsed from
=debian/changelog=. This happens at package-making time, and an error is thrown
if a mismatch is detected.

*** Library install paths
The build system adds the ABI version to both the binary /and/ the =-dev=
packages. Thus in addition to being able to install multiple ABI binary library
packages at the same time, the user can do the same with =-dev= packages. This
is possible because of the particular way in which library files are
distributed. Suppose the latest version in =debian/changelog= is =ABI.REV=, that
the source repo name (in =debian/changelog= and =debian/control=) is =repo= and
that we're building the =libAAA= project. The library will get shipped like
this:

| Package name           | File install location             | Description                                                                                      |
|------------------------+-----------------------------------+--------------------------------------------------------------------------------------------------|
| =liboblong-xxxABI=     | =/usr/lib/libAAA.so.ABI.REV=      | Main DSO. Has both ABI version and revision                                                      |
| =liboblong-xxxABI=     | =/usr/lib/libAAA.so.ABI=          | Symlink to main DSO. Used by the dynamic linker, since this filename matches the =SONAME=        |
| =liboblong-xxxABI-dev= | =/usr/lib/repoABI/libAAA.a=       | Archive for static linking. Used by applications that want to statically link with this library. |
| =liboblong-xxxABI-dev= | =/usr/lib/repoABI/libAAA.so=      | Symlink to main DSO. Used by applications that link with =-L/usr/lib/repoABI -lxxx=              |
| =liboblong-xxxABI-dev= | =/usr/include/repoABI/libAAA/*.h= | Headers                                                                                          |

All the =-dev= files don't have the ABI version in their filenames, so instead
they all ship themselves in a versioned subdirectory. This means that
development users of this library will need to add to their =Makefile.sys=

#+BEGIN_EXAMPLE
CCXXFLAGS += -I/usr/include/repoABI
LDFLAGS   += -L/usr/lib/repoABI
#+END_EXAMPLE

Specific project =Makefiles= however would just say =-lxxx=. If a user project
wants to use a later ABI version of =libAAA=, only the above =Makefile.sys=
entries would need to be touched.

** Distribution details
*** Install paths
Each target of a particular =DIST_TYPES= type is installed into a different
location. Specifically:

| Type                | Install path                              |
|---------------------+-------------------------------------------|
| =DIST_BINS=         | =/usr/bin=                                |
| =DIST_HEADERS=      | =/usr/include/repoABI/libAAA=             |
| =DIST_MANS=         | Standard. Whatever =dh_installman= does.  |
| =DIST_DOCS=         | Standard. Whatever =dh_installdocs= does. |
| =DIST_ETC_OBLONG=   | =/etc/oblong/$(TARGET_NAME)=              |
| =DIST_SHARE_OBLONG= | =/usr/share/oblong/$(TARGET_NAME)=        |

So all the locations are "normal". Configuration files are bundled into a
package-specific path. Upstart confs are all in =/etc/init/oblong/xxx.conf=, so
one can say =start oblong/xxx=.

Another detail that can be customized is the distribution path of the headers.
By default, a project in the =libAAA= directory will ship its headers to
=/usr/include/repoABI/libAAA=. If the developer wants to override this, they
can set

#+BEGIN_EXAMPLE
HEADER_PATH = libs/libAAA
#+END_EXAMPLE

in =libAAA/Makefile=. This would result in the headers being written to
=/usr/include/repoABI/libs/libAAA= instead.

*** Upstart details

Currently the packages are intended to end up in an upstart-enabled system. This
is done by the buildsystem filling in a template to generate the upstart
configuration. The template lives in [[file:../Makefiles/templates/upstart.conf::description%20"Oblong%20upstart%20script%20for%20#NAME#"][=../Makefiles/templates/upstart.conf=]]. This
template is set up with the daemon being launched with the command given in the
=DAEMON_COMMAND= variable. Any extra upstart stanzas can be given in
=UPSTART_STANZAS=. The configuration is copied into the standard configuration
path. For instance, the =frobnicator/Makefile= example contains

#+BEGIN_EXAMPLE
DAEMON_COMMAND = dofrobnicate --thusly

define UPSTART_STANZAS
start on start-frobnicating-signal
endef
#+END_EXAMPLE

The daemon will be run as =dofrobnicate --thusly=, and will be started with a
=start-frobnicating-signal= signal is received by upstart. The configuration
will live in =/etc/init/oblong/$(TARGET_NAME).conf=.

**** Upstart maintainer scripts
It is desirable to automatically start a daemon when its package is installed,
and to stop it when its package is removed. This is done by the maintainer
=postinst= and =prerm= scripts respectively. To create these scripts, I fill in
a template file. The templates live in [[file:../Makefiles/templates/postinst-upstart][=../Makefiles/templates/postinst-upstart=]]
and [[file:../Makefiles/templates/prerm-upstart][=../Makefiles/templates/prerm-upstart=]].

** Writing =debian/control= and =debian/changelog=

There are a few requirements for what is contained in the =debian/control= and
=debian/changelog= files. These are

- The source repository must match. This is the name in the heading in
  =debian/changelog= and in the =Source:= field in =debian/control=.
- Each library /must/ define a =-dev= and a =-dbg= package in =debian/control=
- Each library package has an ABI version in the package name (the binary
  package, the =-dev= and the =-dbg=). The binary package /must/ also have a
  =Provides:= field for the unversioned name. For instance, the =liboblong-aaa1=
  package should have a =Provides: liboblong-aaa= field.

* Internal build system details
** =make= recursion
GNU-make is fundamentally a two-step system. First, the =Makefiles= are parsed
to construct a dependency graph, then this graph is used to build the requested
targets. In /this/ build system a toplevel =Makefile= loops through all the
projects it knows about (=DIRS= variable), and includes all the project-specific
=Makefiles=.

When a user issues a =make=, a file named "=Makefile=" is read. In the root of
the repository, this works just fine, since that file contains the code to
include all the projects. When a =make= is issued in a project directory, that
project's =Makefile= is read instead. As stated previously, project =Makefiles=
/must/ include =Makefile.header= at the start. A function of this file is to
detect that we're trying to =make= in a subdirectory, and to launch a child
=make= in the repository =ROOT=. This child =make= is given some slightly
different targets to only build the project directory. So a =make= in =libAAA=
is equivalent to a =make libAAA/all= in the root. This is an instance of a
recursive =make=. The parent =make= does no work, and simply acts as a chdir.

The Make tool was written a long time ago, so its set of default rules includes
lots of things that have become obsolete long ago. I disable all the default
rules (by doing a =make -rR=) so that Make only considers the rules it is
explicitly given. This is strictly a performance optimization: Make does its job
noticeably faster when these are turned off. This is also accomplished with a
no-op recursive =make=. If the build system sees that =make= was launched
without =-rR=, it launches a child =make -rR=.

** Variable handling
Make fundamentally has a single, global namespace. So if a =Makefile= says
#+BEGIN_EXAMPLE
CFLAGS := -foo
#+END_EXAMPLE
this variable is available /globally/, across /all/ Makefiles that are included
in this session. This is just fine for simple one-project =Makefiles=. However,
here I include many =Makefiles=, which can want multiple values of =CFLAGS=. The
issue is that recipes in Make are evaluated as /deferred/ variables, which means
that the variables present in the recipes are evaluated not when the recipe is
defined, but when the recipe is executed. So the correct value of =$(CFLAGS)=,
say must be available at build time, not just at parsing time.

The solution is target-specific variables, so if I have

#+BEGIN_EXAMPLE
target: CFLAGS = -bar
CFLAGS := -foo
#+END_EXAMPLE

Then regardless of the global values of =$(CFLAGS)=, when building =target=, its
=$(CFLAGS)= will be =-bar=. The build system automatically does this for every
project =Makefile= to preserve various build variables for that project. The
variables being preserved are referred to as *active* variables; they are listed
in [[file:../Makefiles/Makefile.defs::ACTIVE_VARS%20:%3D][=ACTIVE_VARS=]] in =Makefile.defs=. There's also a list of targets that require
preserved variables. /This/ list is in the [[file:../Makefiles/Makefile.defs::TARGETS_NEED_PERSISTENT_ACTIVE_VARS][=TARGETS_NEED_PERSISTENT_ACTIVE_VARS=]]
variable in the same file. Before a project =Makefile= is included, the active
variables are all cleared out using the =$(reset-active-vars)= function. After
the project =Makefile= is processed, the variables are preserved using the
=$(persist-active-vars)= function. This is a double-loop that for each
combination of target =t= and variable =v= evaluates
#+BEGIN_EXAMPLE
$t: $v := $($v)
#+END_EXAMPLE
This saves the value of a variable /for that target/. So when the target =$t= is
built later, it uses its own local value of the variable =$v=, instead of the
global one, which has by now been overwritten.

When the variables have been saved in this way, their global values are no
longer needed. At this point, any use of these variables is a mistake, and
indicates an error in the definition of the =Makefiles=. In order to expose
these errors, I poison these variables with the =$(poison-active-vars)=
function. This function places a string "_poison" into all these variables. If
everything is working correctly, these variables will never be accessed. If
something's wrong, though, these variables will be used and their poisoned
values will break the build. This is preferable to subtle failures that are
uncovered only later.

** Debugging techniques
There are several facilities available when debugging an erroneous build. The
build system itself will print out some debugging information to the console at
parsing time if =$(MAKE_DEBUG)= is set. so =MAKE_DEBUG=1 make= will report some
stuff about the internal going-ons of the build.

Make itself has several useful debugging options. =make -n= prints out what
commands =make= would run without actually running them. =make -d= prints out a
detailed log of what Make does as it does it. Lastly, =make -p= prints out the
full dependency graph that Make creates after all the parsing is complete. This
shows the user all the targets, all of their dependencies, and all the variables
involved. If this isn't enough, there's a fork of GNU make that has better
tracing and debugging facilities: http://bashdb.sourceforge.net/remake/

** Header dependency details
GCC is utilized to make header dependencies. All compiles are invoked with the
=-MMD -MP= gcc options. In addition to compiling the code, these cause gcc to
emit =.d= files for each source file compiled. The =.d= files are =Makefiles=
that list out object dependencies on headers. These =.d= files are included into
our build. One detail here is that when the tree is first checked out (or after
a =make clean=) there are /no/ =.d= files around. In this case =make= knows
nothing of header dependencies. However, it needs to build everything anyway, so
these header dependencies wouldn't have any effect even if they were present.

** Internal variables
=Makefile.defs= defines a number of variables that the build system uses
to do its work. These are not meant to be user-modified.

At this time these variables are

- [[file:../Makefiles/Makefile.defs::DIST_TYPES%20:%3D][=DIST_TYPES=]] has all the variables that can be used to define files for
  distribution. Currently the value is
#+BEGIN_EXAMPLE
 DIST_BINS DIST_HEADERS DIST_MANS DIST_DOCS DIST_ETC_OBLONG DIST_SHARE_OBLONG
#+END_EXAMPLE

- [[file:../Makefiles/Makefile.defs::ACTIVE_VARS][=ACTIVE_VARS=]] are all the variables whose value is saved for per-target
  evaluation, as described in [[Variable handling]]. /All variables that are used in
  build recipes must be listed here/. Currently the value is
#+BEGIN_EXAMPLE
CCXXFLAGS CFLAGS CXXFLAGS LDFLAGS LDLIBS ASFLAGS CPPFLAGS       \
$(DIST_TYPES) HEADER_PATH                                       \
LIB_OBJECTS BIN_TARGET BIN_TARGET_NOINST EXTRACLEAN TARGET_NAME \
LIB_TARGET_SO_BARE LIB_TARGET_SO LIB_TARGET_A IS_UNIT_TEST dir  \
DIST_ALL PACKAGENAME                                            \
DAEMON_COMMAND UPSTART_STANZAS
#+END_EXAMPLE

- [[file:../Makefiles/Makefile.defs::TARGETS_NEED_PERSISTENT_ACTIVE_VARS][=TARGETS_NEED_PERSISTENT_ACTIVE_VARS=]] are all the targets that need variables
  to be saved, as described in [[Variable handling]]. /All targets that have recipes
  using any of the/ =$(ACTIVE_VARS)= /must be listed here/. Current value is
#+BEGIN_EXAMPLE
$$(dir)/%.o $$(dir)/%.1                                   \
$$(LIB_TARGET_SO) $$(LIB_TARGET_SO_BARE) $$(LIB_TARGET_A) \
$$(BIN_TARGET_ALL) $$(dir)/check $$(dir)/install
#+END_EXAMPLE

- [[file:../Makefiles/Makefile.defs::ACTIVE_VARS_CUSTOMIZABLE][=ACTIVE_VARS_CUSTOMIZABLE=]] lists all the active variables that the user is
  allowed to customize on the commandline (see [[User-customized variables]]). The
  user is allowed to customize any non-active variable or active variables in
  this list. Customization of any active variable /not/ in this list is
  unsupported, and will result in an error. Current value is
#+BEGIN_EXAMPLE
CCXXFLAGS CFLAGS CXXFLAGS LDFLAGS ASFLAGS CPPFLAGS
#+END_EXAMPLE

- [[file:../Makefiles/Makefile.defs::USER_RELATIVE_VARS][=USER_RELATIVE_VARS=]] contains a list of all the variables that are
  automatically re-pathed by the build system. This repathing simply means
  prepending =$(dir)/= to the contents of every variable in this list. This
  allows the project =Makefiles= to be written as if the projects were
  standalone, /not/ a part of a much larger repository. Current value is
#+BEGIN_EXAMPLE
$(DIST_TYPES) LIB_OBJECTS BIN_TARGET BIN_TARGET_NOINST EXTRACLEAN
#+END_EXAMPLE

** More linking details
When linking, I /always/ copy the DT_NEEDED flags of the targets to the
resulting executables/libraries (see the =ld= manpage). This is the default in
older distros (like Ubuntu Lucid), but needs to be explicitly set (with
=--copy-dt-needed-entries=) in newer distros (Debian/unstable as of Jan/2012).
What this means is that if =libA.so= needs =libB.so=, =libA.so= would contain a
DT_NEEDED tag to tell it that =libB.so= is required. If an application =app=
links with =libA.so=, it would see the DT_NEEDED tag, and link with =libB.so= as
well. Thus if we're linking dynamically, these chains of needed shared objects
are automatically followed by =ld=. However, as described in [[Linking details]], we
link executables statically if we're not building packages. This means that
instead of building libraries into =.so= files that have DT_NEEDED tags, we're
instead building =.a= files that don't. Thus in this example, =app= would not
automatically know that it needs =libB.a= because =libA.a= doesn't know this
either.

The solution is to use the information available in the build system. =libA.a=
doesn't know it needs =libB.a=, but the =libA/Makefile= has =libB= in its
=LDLIBS=. The build system thus follows these dependency chains itself to
explicitly link =app= to =libA= /and/ =libB=. This is done by the
=$(dir)_CHILDREN_LDLIBS_SYSTEM= variables in =Makefile.footer=.

Another potential way to solve this problem would be to always link dynamically,
but to use an RPATH tag to point the libraries and executables to the local
directories their dependent libraries live in.





