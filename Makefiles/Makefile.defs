# -*- Makefile -*-

# various useful definitions for the build system.
# THIS FILE IS INCLUDED ONCE, BY THE TOP-LEVEL

# all the various types of distribution I can define
DIST_TYPES := DIST_BINS DIST_HEADERS DIST_MANS DIST_DOCS DIST_ETC_OBLONG DIST_SHARE_OBLONG DIST_UPSTART

# variables I use in my recipes and rules. These are reset between includes, and are
# stored to be accessible to my recipes on a per-target basis. This is needed since
# recipes evaluate their variables deferred
ACTIVE_VARS := CCXXFLAGS CFLAGS CXXFLAGS LDFLAGS LDLIBS $(DIST_TYPES)	\
LIB_OBJECTS BIN_TARGET BIN_TARGET_NOINST EXTRACLEAN TARGET_NAME		\
LIB_TARGET_SO_BARE LIB_TARGET_SO LIB_TARGET_A IS_UNIT_TEST dir		\
DESTDIR_MAIN DESTDIR_DEV DIST_ALL API_VERSION PACKAGENAME PODS

# These are a subset of ACTIVE_VARS. These variables are allowed to be
# customized by the user on the cmdline. So the user can say
# CFLAGS=-foo make
ACTIVE_VARS_CUSTOMIZABLE := CCXXFLAGS CFLAGS CXXFLAGS LDFLAGS

# function to apply the customizations. Note that the customizations are
# prepended, NOT appended. This is because gcc searches directories in
# the order given, and I want the user-given overrides to have priority
apply-var-customizations = $(foreach v,$(ACTIVE_VARS_CUSTOMIZABLE),$(eval $v:=$(_USER_CUSTOMIZED_$v) $($v)))


# given a string and an option, strips spaces after the option. For instance
# $(call _strip_spaces_after_option,-L  /tmp/abc -L    /tmp/123,-L)
# becomes '-L/tmp/abc -L/tmp/123'
# A side effect is that ALL consecutive spaces are collapsed to one
_strip_spaces_after_option = $(subst $(2) ,$(2),$(1:%=%))

# given a string, retrieves all arguments to a given option. So
# $(call _get_option_args,-foo -L  /tmp/abc -bar -L    /tmp/123,-L)
# gives '/tmp/abc /tmp/123'
# A side effect is that ALL consecutive spaces are collapsed to one
_get_option_args = $(patsubst $(2)%,%,$(filter $(2)%,$(call _strip_spaces_after_option,$(1),$(2))))

# makes sure every directory in the passed-in list exists. Error if not,
# no output if yes. Second arg used in the error message
_assert_alldirs_exist = $(foreach d,$(1),$(if $(wildcard $d),,$(error $(2) given a nonexisting directory ($d) when building $@))) \


# If the user customized the LDFLAGS with -L, I want to make this
# directory selection propagate to later links (runtime, etc). I thus
# set RPATH to the same directory.
#
# If there's a -L, disallow package building. This is to make sure that
# generated packages will work.
#
# Some things to worry about: -L logically must reside in LDFLAGS. If
# somebody puts it in LDLIBS, I'll complain about it. Also, gcc accepts
# both '-L dir' and '-Ldir'. I like the no-spaces version so I need to
# detect and convert the with-spaces version.
#
# This function must be deferred so that it can see the per-target
# LDFLAGS and LDLIBS variables
_LDFLAGS_SEARCH_DIRS = $(call _get_option_args,$(LDFLAGS),-L)
# makes sure we're using LDFLAGS; makes sure -L dirs exist, adds RPATH for every -L directory
comma :=,
_LDFLAGS_POSTPROCESS = \
$(if $(filter -L%,$(LDLIBS)), $(error LDLIBS '$(LDLIBS)' has -L when building $@. This must be in LDFLAGS instead)) \
$(if $(filter -L%,$(LDFLAGS)),\
  $(if $(filter $(MAKECMDGOALS),install), \
    $(error When building packages ALL libraries must be in a package; -L not allowed. Error when building $@))) \
$(call _assert_alldirs_exist,$(_LDFLAGS_SEARCH_DIRS),-L) \
$(addprefix -Wl$(comma)-rpath$(comma),$(abspath $(_LDFLAGS_SEARCH_DIRS))) \
$(LDFLAGS)


# make sure any -I directories exist
# build with -O2 if we don't already have a -Ox
_CCXXFLAGS_SEARCH_DIRS = $(call _get_option_args,$(1),-I)
_CCXXFLAGS_POSTPROCESS = \
$(call _assert_alldirs_exist,$(_CCXXFLAGS_SEARCH_DIRS),-I) \
$(1) \
$(if $(filter -O%,$(1)),,-O2)





# a function to reset the active variables (before a new include) and to poison the
# global active variables. No global variables should be used, and poisoning makes it
# obvious that something wrong is happening
reset-active-vars  = $(foreach v,$(ACTIVE_VARS),$(eval $v := ))
poison-active-vars = $(foreach v,$(ACTIVE_VARS),$(eval $v := $(v)_poison))

# all targets that have recipes defined, which thus need variables accessible to them
# through deferred evaluation. This double-loop generates a function that can be
# evaluated to generate lines such as
# $(LIB_TARGET_SO):  LDFLAGS     := $(LDFLAGS)
#
# This is done for all var/target combinations. This is a bit overkill, since all
# recipes don't need all the variables, but it doesn't hurt
TARGETS_NEED_PERSISTENT_ACTIVE_VARS := $$(dir)/%.o $$(dir)/%.1 $$(LIB_TARGET_SO) \
$$(BIN_TARGET_ALL) $$(dir)/check $$(dir)/install


persist-active-vars = $(foreach v,$(ACTIVE_VARS),\
	$(foreach t,$(TARGETS_NEED_PERSISTENT_ACTIVE_VARS),\
		$(eval $t: $v := $$($v))))


# variables that may be specified in the user Makefile that use relative paths.
# Makefile repaths them to $(dir) using the following function
USER_RELATIVE_VARS = $(DIST_TYPES) LIB_OBJECTS BIN_TARGET BIN_TARGET_NOINST EXTRACLEAN PODS
relocate-vars = $(foreach v,$(USER_RELATIVE_VARS),$(eval $v := $(addprefix $(dir)/,$($(v)))))



# 
# basic functional stuff. These are a perl-style grep and map. You call these like
#
# $(call grep,cond,list)
# where cond is another function
grep = $(foreach x,$(2),$(if $(call $(1),$(x)),$(x)))
map  = $(foreach x,$(2),$(call $(1),$(x)))


# a non-destructive wildcard function. Takes a list; any element that matches
# nothing is left alone as is. This also removes duplicates through the $(sort)
# function. Thus it also sorts the list.
soft-wildcard = $(sort $(foreach d,$(1),$(or $(wildcard $(d)),$(d))))

# A wildcard function that reports an error if it encounters any term
# that expands to nothing (everything MUST exist). Similarly, it removes
# duplicates and sorts
hard-wildcard = $(sort $(foreach d,$(1),$(or $(wildcard $(d)),$(error Wildcard matched nothing: $(1)))))



# The 'relpath' function takes a list of paths (local or absolute) and
# returns a cleaned-up path relative to ROOT. For instance, something
# like libRetro/../libAttic gets converted to libAttic. The root gets
# converted to '.'. The empty string is returned unchanged. If an
# out-of-tree absolute path is given, an error is generated
#
# These helpers take a list of paths (relative or absolute) and return
# only those that are (or not) that are in our repo
filter-intree-predicate     = $(filter     $(ROOT)%,$(abspath $(1)))
filter-out-intree-predicate = $(filter-out $(ROOT)%,$(abspath $(1)))
filter-intree     = $(call grep,filter-intree-predicate,$(1))
filter-out-intree = $(call grep,filter-out-intree-predicate,$(1))
#
# this makes paths such as '/libRetro' or ''. 
relpath-withinitial-slash = $(if $(call filter-intree,$(1)),$(patsubst $(ROOT)%,%,$(abspath $(1))), \
	$(error out-of-tree path given: $(1)))
# this converts it to 'libRetro' or '.'
relpath-single = $(if $(relpath-withinitial-slash),$(relpath-withinitial-slash:/%=%),.)
#
# find the relpath of each element
relpath = $(and $(1),$(call map,relpath-single,$(1)))




# base package names from TARGET_NAMEs
PACKAGENAME_BASE_LIB = liboblong-$(shell echo $(TARGET_NAME) | sed 's/^lib//' | tr A-Z a-z)
PACKAGENAME_BASE_BIN = oblong-$(shell echo $(TARGET_NAME) | tr A-Z a-z | tr _ -)
