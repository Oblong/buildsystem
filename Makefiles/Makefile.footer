# -*- Makefile -*-

# THIS FILE IS INCLUDED BY EACH USER Makefile

# we only bother to do anything if we were asked to do a make from the
# ROOT directory. In not, Makefile.header has already defined a
# from-root sub-make that will do all the work, so we do nothing here
ifeq ($(nonroot_make),)

$(if $(MAKE_DEBUG), $(info At top of the $(dir) Makefile))

# if we don't already have a target name, use the directory. So code in the
# libRetro directory would produce libRetro.so and libRetro.a. I can't use ?=
# here because it checks for definedness, not truth
TARGET_NAME  := $(or $(TARGET_NAME),$(notdir $(dir)))
IS_UNIT_TEST := $(filter %/tests,$(dir))

# basic error checking
ifeq ($(IS_UNIT_TEST),)

ifneq ($(TARGET_NAME:lib%=lib),lib)
ifneq ($(LIB_OBJECTS),)
$(error Target "$(TARGET_NAME)" from dir "$(dir)" has LIB_OBJECTS, so it MUST start with "lib")
endif
ifneq ($(DIST_HEADERS),)
$(error Target "$(TARGET_NAME)" from dir "$(dir)" has DIST_HEADERS, so it MUST start with "lib")
endif
endif
ifeq ($(TARGET_NAME:lib%=lib),lib)
ifeq ($(LIB_OBJECTS),)
$(error Target "$(TARGET_NAME)" from dir "$(dir)" starts with lib..., but has no LIB_OBJECTS!)
endif
endif

else # ifeq ($(IS_UNIT_TEST),)
ifneq ($(LIB_OBJECTS),)
$(error Unit tests $(dir) have LIB_OBJECTS. This is not allowed)
endif
endif

#################### Shared object versioning #########################

# none of this applies for unit tests
ifeq ($(IS_UNIT_TEST),)

# I parse the version from debian/changelog. I look at the first line of that
# file and get everything betwee '(' and the first '-'. These lines look like
#
# oblong-perception (3.11-dima-2) lucid; urgency=low
#
# debian has a dpkg-parsechangelog tool to do this for me, but it's
# significantly slower than the awk version below, so I don't use it
LPAREN := (
VERSION := $(or $(VERSION),$(strip $(shell awk '{ sub(".*\\$(LPAREN)",""); sub("-.*",""); print; exit}' debian/changelog)))
$(if $(VERSION),,$(error "Couldn't parse version from debian/changelog"))


# If I'm building a library, I grab its API version from the name of its debian
# package. So for instance, if debian/control says that I'm building the
# liboblong-retro1 package then the API version for libRetro is 1.
ifneq ($(LIB_OBJECTS),)

PACKAGENAME_BASE := $(PACKAGENAME_BASE_LIB)
API_VERSION := $(shell awk '/Package:[ 	]*$(PACKAGENAME_BASE)[0-9]+[ 	]*$$/ { sub("Package:[ 	]*$(PACKAGENAME_BASE)",""); print; exit;}' debian/control)
$(if $(API_VERSION),,$(error Couldn't parse API version for $(TARGET_NAME). Maybe the package isn't defined in debian/control?))

else

# not a library. but is a package defined?
PACKAGENAME_BASE := $(PACKAGENAME_BASE_BIN)

$(if $(shell grep 'Package:[ 	]*$(PACKAGENAME_BASE)[ 	]*$$' debian/control),, \
  $(error No package defined for $(PACKAGENAME_BASE)))

endif

SO_VERSION := $(API_VERSION).$(VERSION)

endif # ifeq ($(IS_UNIT_TEST),)

#################### variable setup ###################################

# the user's makefile gives all the targets in reference to $(dir), so I locate
# them absolutely in the tree
$(eval $(relocate-vars))


# if we have libraries, define their names
ifneq ($(LIB_OBJECTS),)
LIB_TARGET_SO_BARE := $(dir)/$(TARGET_NAME).so
LIB_TARGET_SO	   := $(LIB_TARGET_SO_BARE).$(SO_VERSION)
LIB_TARGET_A       := $(dir)/$(TARGET_NAME).a
endif


# I separate LDLIBS into those that are a part of this repo and those
# that aren't. All %.so LDLIBS are examined. If their path is in this
# repo, they go into LDLIBS_PROJECT; otherwise, LDLIBS_SYSTEM. I keep
# these as deferred references to try to capture the per-target LDLIBS
# settings
#
# General logic:
# ../
# if( /%.so )
# {
#   if(in tree)
#     LDLIBS_PROJECT
#   else
#     LDLIBS_SYSTEM
# }
# else if( %.so )
# {
#   if( $(dir)/% in tree)
#     LDLIBS_PROJECT = $(dir)/%
#   else
#     LDLIBS_SYSTEM  = $(dir)/%
# }
# else
# {
#   LDLIBS_SYSTEM
# }
#
LDLIBS_onlyso	     = $(filter      %.so,$(LDLIBS))
LDLIBS_notso	     = $(filter-out  %.so,$(LDLIBS))
LDLIBS_addpath       = $(if $(filter /%,$(1)),$(1),$(dir)/$(1))
LDLIBS_onlyso_pathed = $(call map,LDLIBS_addpath,$(LDLIBS_onlyso))
LDLIBS_SYSTEM        = $(LDLIBS_notso)
LDLIBS_SYSTEM       += $(call                filter-out-intree, $(LDLIBS_onlyso_pathed))
LDLIBS_PROJECT       = $(call relpath,$(call filter-intree,     $(LDLIBS_onlyso_pathed)))





# used to make gcc output header dependency information. All source
# files generated .d dependency definitions that are included at the
# bottom of this file
ALLCFLAGS += -MMD -MP

# if we don't care how we link the code, use plain cc
CC_LINKER ?= $(CC)

CFLAGS   += $(ALLCFLAGS) -g
CXXFLAGS += $(ALLCFLAGS) -g

BIN_TARGET_ALL := $(BIN_TARGET) $(BIN_TARGET_NOINST)


# needed for the dynamically-linked object
$(LIB_OBJECTS): CXXFLAGS += -fPIC
$(LIB_OBJECTS): CFLAGS   += -fPIC

# install all the binaries that need installing
DIST_BINS += $(BIN_TARGET)





############## rules to build my stuff ################################
#
# I set up all the variables, now use them to define the recipes

# first stuff to convert the PODs to HTML, manpages, and to set their
# distribution
$(dir)/%.1: $(dir)/%.pod
	podchecker $<
	pod2man --center "Oblong Industries" --release "$(TARGET_NAME) $(VERSION)" $< $@

$(dir)/%-man.html: $(dir)/%.pod
	pod2html $< > $@

DIST_MANS +=$(strip $(patsubst %.pod,%.1,       $(call hard-wildcard,$(PODS))))
DIST_DOCS +=$(strip $(patsubst %.pod,%-man.html,$(call hard-wildcard,$(PODS))))

ifneq ($(LIB_OBJECTS),)
$(LIB_TARGET_SO_BARE): $(LIB_TARGET_SO)
	ln -fs $(notdir $<) $@
endif

$(if $(MAKE_DEBUG), $(info Defining rules for libs. o: $(LIB_TARGET_SO); a: $(LIB_TARGET_A)))

$(LIB_TARGET_A): $(LIB_OBJECTS)
	ar rcvu $@ $^

# Here instead of specifying $^, I do just the %.o parts and then the
# others. This is required to make the linker happy to see the dependent
# objects first and the dependency objects last
$(LIB_TARGET_SO): LDFLAGS += -shared -fPIC -Wl,-soname,$(notdir $(LIB_TARGET_SO_BARE)).$(API_VERSION)
$(LIB_TARGET_SO): $(LDLIBS_PROJECT) $(LIB_OBJECTS)
	$(CC_LINKER) $(LDFLAGS) $(filter %.o, $^) $(filter-out %.o, $^) $(LDLIBS_SYSTEM) -o $@

# I'm using $$ here to delay the variable expansion until later, so that the
# rules are generated keeping the variable references intact. For instance, the
# project may have defined a per-target LDLIBS:
#
# executable: LDLIBS += -lfoo
#
# LIB_TARGET_A and LIB_TARGET_SO can't vary per target, so I expand them now, hence the single $
#
# This means that I WANT LDLIBS to be deferred
#
# Here instead of specifying $^, I do just the %.o parts and then the
# others. This is required to make the linker happy to see the dependent
# objects first and the dependency objects last.
#
# I have rules for building both static and a dynamic binaries. The
# dynamic libraries are ONLY built when I'm installing to make packages.
# Thus these binaries are PHONY (always rebuilt to build on top of the
# static ones). They are also INTERMEDIATE so that make deletes them
# when done installing. This ensures that the "normal" static versions
# will be built after and install
#
# Lastly, static links have no benefit of the DT_NEEDED tags in the
# shared objects. Thus they more of the libraries given on the
# commandline. Here I save the LDLIBS_SYSTEM for each project, and use
# LDLIBS_PROJECT to construct all the LDLIBS_SYSTEM that come from a
# project's children. I can then link with those libraries. I make two
# variables $(dir)_LDLIBS_SYSTEM for the current LDLIBS_SYSTEM
# and $(dir)_CHILDREN_LDLIBS_SYSTEM for all of the children's
# LDLIBS_SYSTEM.
#
# $(sort) sorts and removes duplicates. I don't really want to sort,
# actually since order may matter, but I'll let the linker tell me this
$(dir)_LDLIBS_SYSTEM := $(LDLIBS_SYSTEM)
$(foreach lib,$(patsubst %/,%,$(dir $(LDLIBS_PROJECT))),$(eval \
  $(dir)_CHILDREN_LDLIBS_SYSTEM += $$($(lib)_LDLIBS_SYSTEM) $$($(lib)_CHILDREN_LDLIBS_SYSTEM)))

define BIN_TARGET_template_static
$(1): $(1).o $(LIB_TARGET_A) $$(LDLIBS_PROJECT:%.so=%.a)
	$$(CC_LINKER) $$(LDFLAGS) $$(filter %.o, $$^) $$(filter-out %.o, $$^) \
		$$(sort $$($$(dir)_CHILDREN_LDLIBS_SYSTEM)) $$(LDLIBS_SYSTEM) -o $$@
endef

define BIN_TARGET_template_dynamic
$(1): $(1).o $(LIB_TARGET_SO) $$(LDLIBS_PROJECT)
	$$(CC_LINKER) $$(LDFLAGS) $$(filter %.o, $$^) $$(filter-out %.o, $$^) \
		$$(LDLIBS_SYSTEM) -o $$@
.PHONY:        $(1)
.INTERMEDIATE: $(1)
endef

# I pick static linking if I'm not installing; if I'm installing use dynamic linking
BIN_TARGET_template = $(if $(filter $(MAKECMDGOALS),install),$(BIN_TARGET_template_dynamic),$(BIN_TARGET_template_static))

# generate the recipe for every target
$(foreach target,$(BIN_TARGET_ALL),$(eval $(call BIN_TARGET_template,$(target))))


#################### clean and all and install rules ##################

# can't install unit tests
ifeq ($(IS_UNIT_TEST),)
include Makefile.install
endif

clean_files := $(addprefix $(dir)/, *.a *.o *.so *.so.* *.d)
clean_files += pod2htmi.tmp pod2htmd.tmp $(addprefix $(dir)/, *.1 *-man.html)

clean_files += $(BIN_TARGET_ALL) $(EXTRACLEAN)

# This is done with an eval to immediately evaluate the files-to-clean list
define CLEAN_template
$(dir)/clean:
	rm -rf $(clean_files)
endef
$(eval $(CLEAN_template))


$(dir)/all: $(LIB_TARGET_A) $(BIN_TARGET_ALL)

clean: $(dir)/clean

# don't build unit tests unless asked
ifeq ($(IS_UNIT_TEST),)
all:   $(dir)/all
endif # ifeq ($(IS_UNIT_TEST),)

.PHONY: clean all $(dir)/clean $(dir)/all

# "making" a directory is equivalent to making all there
$(dir):  $(dir)/all
$(dir)/: $(dir)/all

.PHONY: $(dir) $(dir)/


#################### unit tests #######################################

check: $(dir)/check
.PHONY: $(dir)/check check






# the header dependencies
-include $(dir)/*.d


# The recipes used to build targets are evaluated deferred (when needed), so by
# default, the current values of CFLAGS, etc will NOT be used when the recipe is
# evaluated. Here I save these variables on a per-target basis. This makes
# current variables "persist"
$(eval $(persist-active-vars))

# I have now used all my build flags, so nothing should be using them. If some
# build rule STILL uses these (through deferred evaluation) then it's a bug in
# the Makefiles that should be fixed. I poison the variables to make this clear
$(eval $(poison-active-vars))


endif # ifeq ($(nonroot_make),)
