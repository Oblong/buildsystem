# -*- Makefile -*-

# if we don't already have a target name, use the directory. So code in
# the libRetro directory would produce libRetro.so and libRetro.a
TARGET_NAME ?= $(notdir $(realpath .))


LIB_OBJECTS = $(patsubst %.C, %.o, $(patsubst %.c, %.o, $(LIB_SOURCES)))
LIB_TARGET_SO = $(TARGET_NAME:%=%.so)
LIB_TARGET_A = $(TARGET_NAME:%=%.a)

# used to make gcc output header dependency information. All source
# files generated .d dependency definitions that are included at the
# bottom of this file
ALLCFLAGS += -MMD -I$(ROOT)

CFLAGS   += $(ALLCFLAGS)
CXXFLAGS += $(ALLCFLAGS)

BIN_TARGET_ALL = $(BIN_TARGET) $(BIN_TARGET_NOINST)
LIB_TARGET_ALL = $(LIB_TARGET_SO) $(LIB_TARGET_A)

# make each depended project library. A Makefile can debine
# LDLIBS_PROJECT to contain all the .so files IN THIS REPO that we
# depend on here. Here I make sure that those are built before I try to
# build THIS library.
#
# There are 2 targets:
# LDLIBS_PROJECT and LDLIBS_PROJECT_BUILD
#
# LDLIBS_PROJECT is the actual .so I depend on. LDLIBS_PROJECT_BUILD is
# a virtual prerequesite used to ALWAYS run the recursive make to build
# the .so (if needed). Here I always run the recursive make, and if the
# .so was updated, I rebuild my dependencies.
LDLIBS_PROJECT_BUILD = $(LDLIBS_PROJECT:%=%_BUILD)
define LDLIB_BUILD_template
$(1):
	$(MAKE) -C $(dir $(1)) $(subst $(notdir $(1)),_BUILD,)

.PHONY: $(1)
endef
$(foreach lib,$(LDLIBS_PROJECT_BUILD),$(eval $(call LDLIB_BUILD_template,$(lib))))


# If TESTS is defined, run the tests when making 'check';
# Else if there's a 'tests' subdirectory, make 'check' there when making 'check' here;
# Else do nothing
ifneq ($(TESTS),)
check:
	for thistest in $(TESTS); do \
		./$$thistest || break; \
	done
else

# not in 'tests'. Is there a tests/Makefile?
ifneq ($(wildcard tests/Makefile),)
check:
	$(MAKE) -C tests check

else
check:
	@echo "No testing Makefile found"
endif
endif




.DEFAULT_GOAL := all



all: $(LIB_TARGET_ALL) $(BIN_TARGET_ALL)

$(LIB_OBJECTS): ALLCFLAGS += -fPIC

$(LIB_TARGET_A): $(LIB_OBJECTS)
	ar rcvu $@ $^

$(LIB_TARGET_SO): LDFLAGS += -shared -fPIC
$(LIB_TARGET_SO): $(LIB_OBJECTS)
	$(LINK.o) $^ -o $@



# each BIN_TARGET depends on its own .c file and on the LIB_TARGET_SO
# shared object. Here I generate lots of rules like blah: blah.o to get
# the former. The latter is included in the following rule
define BIN_TARGET_template
$(1): $(1).o
endef
$(foreach target,$(BIN_TARGET_ALL),$(eval $(call BIN_TARGET_template,$(target))))

# see comment about LDLIBS_PROJECT_BUILD above
$(BIN_TARGET_ALL): $(LIB_TARGET_SO) $(LDLIBS_PROJECT) | $(LDLIBS_PROJECT_BUILD)
	$(LINK.o) $^ $(LDLIBS) -o $@




DIRHERE = $(subst $(realpath $(ROOT))/,,$(realpath .))

install: $(LIB_TARGET_SO)
	mkdir -p $(DESTDIR)/usr/include/$(DIRHERE)
	mkdir -p $(DESTDIR)/usr/bin
	mkdir -p $(DESTDIR)/usr/lib
	install $(INC_INSTALL) $(DESTDIR)/usr/include/$(DIRHERE)
	install -s $(BIN_TARGET) $(DESTDIR)/usr/bin
	install -s $(LIB_TARGET_SO) $(DESTDIR)/usr/lib


ALLCLEAN := *.a *.o *.so *.d
ALLCLEAN += $(BIN_TARGET_ALL) $(EXTRACLEAN)

clean:
	rm -rf $(ALLCLEAN)

-include *.d


# include the system-dependent variables and anything oblong-specific
$(ROOT) ?= .
include $(ROOT)/Makefile.sys

.PHONY: all install clean check

