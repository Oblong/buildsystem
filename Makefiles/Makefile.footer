# -*- Makefile -*-
#
# This is a general makefile to support builds of multi-directory
# subprojects in a single repo. Each directory would generate one .so
# library for dynamic linking, one .a library for static linking, and
# possibly some executable binaries.
#
# Two versions of the executables are built: ones using static linking
# and others using dynamic linking. In the project tree, the executable
# names specified in the Makefile are the statically-linked executables.
# Dynamically-linked ones are called binaryname.dynamic. When the debian
# packager runs the install rule, it grabs the dynamically-linked
# executables, so that the installed package can use the shared objects.
#
# There is one package generated per directory

# A project in a particular directory
# would define a Makefile that includes this one. Example:
#
# LIB_OBJECTS = \
#   gs_bmpmask.o \
#   gs_calibopt.o \
#   ...
#   gs_wanddesign.o \
#   gs_wandtracker.o
#
# BIN_TARGET = \
#   GScp2xcp \
#   GSxcp2cp \
#   #
#
# BIN_TARGET_NOINST = \
#   BatchTagDesignCmd \
#   ...
#   TestCalibration \
#   #
#
# LDLIBS  += -lm -llbfgs -lLoam++ $(RTLIBS)
# LDFLAGS += --no-undefined
#
#
# BatchTagDesignCmd: LDLIBS += -lyaml -lpng
#
# ROOT   = ..
# include $(ROOT)/Makefile.footer

# This is the libRetro Makefile. The user MUST define the ROOT path to
# this Makefile.footer file. The user should define the LDLIBS and
# LDFLAGS as with any Makefile. Objects that generate the library .so or
# .a must be given in LIB_OBJECTS. These are generally named xxx.o built
# from xxx.{C,c,cc,cpp,....}. The binaries that are built are defined in
# BIN_TARGET and BIN_TARGET_NOINST. The former are installed into the
# final package, while the latter are not.
#
# The library and package by default will be named for the directory
# they are in. If we want this to NOT be the case, we should define
# TARGET_NAME.
#
# If a directory depends on other directories IN THIS REPO, add those
# .so files to the LDLIBS_PROJECT variable. This library will then be
# built and linked in


# if we don't already have a target name, use the directory. So code in
# the libRetro directory would produce libRetro.so and libRetro.a
TARGET_NAME ?= $(notdir $(realpath .))

LIB_TARGET_SO = $(TARGET_NAME).so
LIB_TARGET_A  = $(TARGET_NAME).a

# used to make gcc output header dependency information. All source
# files generated .d dependency definitions that are included at the
# bottom of this file
ALLCFLAGS += -MMD -I$(ROOT)

CFLAGS   += $(ALLCFLAGS)
CXXFLAGS += $(ALLCFLAGS)

BIN_TARGET_ALL = $(BIN_TARGET) $(BIN_TARGET_NOINST)
LIB_TARGET_ALL = $(LIB_TARGET_SO) $(LIB_TARGET_A)

# make each depended project library. A Makefile can debine
# LDLIBS_PROJECT to contain all the .so files IN THIS REPO that we
# depend on here. Here I make sure that those are built before I try to
# build THIS library.
#
# There are 2 targets:
# LDLIBS_PROJECT and LDLIBS_PROJECT_BUILD
#
# LDLIBS_PROJECT is the actual .so I depend on. LDLIBS_PROJECT_BUILD is
# a virtual prerequesite used to ALWAYS run the recursive make to build
# the .so (if needed). Here I always run the recursive make, and if the
# .so was updated, I rebuild my dependencies.
LDLIBS_PROJECT_BUILD = $(LDLIBS_PROJECT)_BUILD
define LDLIB_BUILD_template
$(1):
	$(MAKE) -C $(dir $(1)) $(subst $(notdir $(1)),_BUILD,)

.PHONY: $(1)
endef
$(foreach lib,$(LDLIBS_PROJECT_BUILD),$(eval $(call LDLIB_BUILD_template,$(lib))))


# If TESTS is defined, run the tests when making 'check';
# Else if there's a 'tests' subdirectory, make 'check' there when making 'check' here;
# Else do nothing
ifneq ($(TESTS),)
check:
	for thistest in $(TESTS); do \
		./$$thistest || break; \
	done
else

# not in 'tests'. Is there a tests/Makefile?
ifneq ($(wildcard tests/Makefile),)
check:
	$(MAKE) -C tests check
else
check:
	@echo "No testing Makefile found"
endif
endif




.DEFAULT_GOAL := all


all: $(LIB_TARGET_A) $(BIN_TARGET_ALL)

# needed for the dynamically-linked object
$(LIB_OBJECTS): ALLCFLAGS += -fPIC

$(LIB_TARGET_A): $(LIB_OBJECTS)
	ar rcvu $@ $^

$(LIB_TARGET_SO): LDFLAGS += -shared -fPIC
$(LIB_TARGET_SO): $(LIB_OBJECTS)
	$(LINK.o) $^ -o $@



# each BIN_TARGET depends on its own .c file and on the LIB_TARGET_SO
# shared object. Here I generate lots of rules like
# blah: blah.o libs
#       g++ blah.o thislib.a libs -o blah
# blah.dynamic: blah.o libs
#       g++ blah.o thislib.so libs -o blah
# see comment about LDLIBS_PROJECT_BUILD above
#
# I'm using $$ here to delay the variable expansion until later, so that
# the rules are generated keeping the variable references intact.
define BIN_TARGET_template
$(1): $(1).o $$(LIB_TARGET_A) $$(LDLIBS_PROJECT:%.so=%) | $$(LDLIBS_PROJECT_BUILD)
	$$(CXX) $$(LDFLAGS) $$^ $$(LDLIBS) -o $$@

$(1).dynamic: $(1).o $$(LIB_TARGET_SO) $$(LDLIBS_PROJECT) | $$(LDLIBS_PROJECT_BUILD)
	$$(CXX) $$(LDFLAGS) $$^ $$(LDLIBS) -o $$@
endef
$(foreach target,$(BIN_TARGET_ALL),$(eval $(call BIN_TARGET_template,$(target))))









DIRHERE = $(subst $(realpath $(ROOT))/,,$(realpath .))

install: $(LIB_TARGET_SO)
	mkdir -p $(DESTDIR)/usr/include/$(DIRHERE)
	mkdir -p $(DESTDIR)/usr/bin
	mkdir -p $(DESTDIR)/usr/lib
	install $(INC_INSTALL) $(DESTDIR)/usr/include/$(DIRHERE)
	install -s $(BIN_TARGET) $(DESTDIR)/usr/bin
	install -s $(LIB_TARGET_SO) $(DESTDIR)/usr/lib


ALLCLEAN := *.a *.o *.so *.d
ALLCLEAN += $(BIN_TARGET_ALL) $(EXTRACLEAN)

clean:
	rm -rf $(ALLCLEAN)

-include *.d


# include the system-dependent variables and anything oblong-specific
$(ROOT) ?= .
include $(ROOT)/Makefile.sys

.PHONY: all install clean check

