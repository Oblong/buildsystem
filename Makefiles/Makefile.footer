# -*- Makefile -*-

fulldir := $(abspath $(dir))

$(if $(MAKE_DEBUG), $(info At top of the $(dir) Makefile))

# include the system-dependent variables and anything oblong-specific
include $(ROOT)/Makefile.sys


# if we don't already have a target name, use the directory. So code in the
# libRetro directory would produce libRetro.so and libRetro.a. I can't use ?=
# here because it checks for definedness, not truth
TARGET_NAME := $(or $(TARGET_NAME),$(notdir $(abspath $(dir))))

# if we don't yet know whether this is a local build or not, it IS.
# LOCALDIR_BUILD not set implies that we haven't seen the top level yet
LOCALDIR_BUILD ?= 1


#################### Shared object versioning #########################

# I parse the version from debian/changelog. I look at the first line of that
# file and get everything betwee '(' and the first '-'. These lines look like
#
# oblong-perception (3.11-dima-2) lucid; urgency=low
#
# debian has a dpkg-parsechangelog tool to do this for me, but it's
# significantly slower than the awk version below, so I don't use it
LPAREN := (
VERSION := $(or $(VERSION),$(strip $(shell awk '{ sub(".*\\$(LPAREN)",""); sub("-.*",""); print; exit}' $(ROOT)/debian/changelog)))
$(if $(VERSION),,$(error "Couldn't parse version from debian/changelog"))


# If I'm building a library, I grab its API version from the name of its debian
# package. So for instance, if debian/control says that I'm building the
# liboblong-retro1 package then the API version for libRetro is 1.
ifneq ($(LIB_OBJECTS),)

# duplicated from Makefile.install. Should break out into a template or something
PACKAGENAME_BASE := liboblong-$(shell echo $(TARGET_NAME) | sed 's/^lib//' | tr A-Z a-z)
API_VERSION := $(shell awk '/Package:[ 	]*$(PACKAGENAME_BASE)[0-9]+[ 	]*$$/ { sub("Package:[ 	]*$(PACKAGENAME_BASE)",""); print; exit;}' $(ROOT)/debian/control)
$(if $(API_VERSION),,$(error "Couldn't parse API version for $(TARGET_NAME)"))


endif

SO_VERSION := $(API_VERSION).$(VERSION)

#######################################################################


# I separate LDLIBS into those that are a part of this repo and those that
# aren't. If it's ../%.so, I assume that it's in this project. This logic may
# need to be improved in the future
LDLIBS_PROJECT := $(filter     ../%.so,$(LDLIBS))
LDLIBS         := $(filter-out ../%.so,$(LDLIBS))



# the user's makefile gives all the targets in reference to $(dir), so I locate
# them absolutely in the tree
DIST_BINS		:= $(addprefix $(dir)/,$(DIST_BINS))
DIST_MANS		:= $(addprefix $(dir)/,$(DIST_MANS))
DIST_DOCS		:= $(addprefix $(dir)/,$(DIST_DOCS))
DIST_ETC_OBLONG		:= $(addprefix $(dir)/,$(DIST_ETC_OBLONG))
DIST_UPSTART		:= $(addprefix $(dir)/,$(DIST_UPSTART))
LIB_OBJECTS		:= $(addprefix $(dir)/,$(LIB_OBJECTS))
BIN_TARGET		:= $(addprefix $(dir)/,$(BIN_TARGET))
BIN_TARGET_NOINST	:= $(addprefix $(dir)/,$(BIN_TARGET_NOINST))
EXTRACLEAN              := $(addprefix $(dir)/,$(EXTRACLEAN))
LDLIBS_PROJECT          := $(addprefix $(dir)/,$(LDLIBS_PROJECT))




# if we have libraries, define their names
ifneq ($(LIB_OBJECTS),)
LIB_TARGET_SO_BARE := $(dir)/$(TARGET_NAME).so
LIB_TARGET_SO	   := $(LIB_TARGET_SO_BARE).$(SO_VERSION)
LIB_TARGET_A       := $(dir)/$(TARGET_NAME).a
endif


# make gets confused when I refer to the same file from different paths, so I
# here absolute paths here to remove the confusion. For instance it doesn't know
# to make libRetro/libRetro.so if libAttic/../libRetro/libRetro.so is asked for
LIB_TARGET_SO_BARE := $(abspath $(LIB_TARGET_SO_BARE))
LIB_TARGET_SO	   := $(abspath $(LIB_TARGET_SO))
LIB_TARGET_A       := $(abspath $(LIB_TARGET_A))
LDLIBS_PROJECT     := $(abspath $(LDLIBS_PROJECT))


ifneq ($(LIB_OBJECTS),)
$(LIB_TARGET_SO_BARE): $(LIB_TARGET_SO)
	ln -fs $(notdir $<) $@
endif






# used to make gcc output header dependency information. All source
# files generated .d dependency definitions that are included at the
# bottom of this file
ALLCFLAGS += -MMD

# if we don't care how we link the code, use plain cc
CC_LINKER ?= $(CC)

CFLAGS   += $(ALLCFLAGS)
CXXFLAGS += $(ALLCFLAGS)

BIN_TARGET_ALL := $(BIN_TARGET) $(BIN_TARGET_NOINST)


# needed for the dynamically-linked object
$(LIB_OBJECTS): CXXFLAGS += -fPIC
$(LIB_OBJECTS): CFLAGS   += -fPIC

$(if $(MAKE_DEBUG), $(info Defining rules for libs. o: $(LIB_TARGET_SO); a: $(LIB_TARGET_A)))

$(LIB_TARGET_A): $(LIB_OBJECTS)
	ar rcvu $@ $^

$(LIB_TARGET_SO): LDFLAGS += -shared -fPIC -Wl,-soname,$(notdir $(LIB_TARGET_SO_BARE)).$(API_VERSION)
$(LIB_TARGET_SO): $(LDLIBS_PROJECT) $(LIB_OBJECTS)
	$(CC_LINKER) $(LDFLAGS) $(LDLIBS) $^ -o $@

# I'm using $$ here to delay the variable expansion until later, so that the
# rules are generated keeping the variable references intact. For instance, the
# project may have defined a per-target LDLIBS:
#
# executable: LDLIBS += -lfoo
#
# LIB_TARGET_A and LIB_TARGET_SO can't vary per target, so I expand them now, hence the single $
#
# This means that I WANT LDLIBS to be deferred
#
# Here instead of specifying $^, I do just the %.o parts and then the
# others. This is required to make the linker happy to see the dependent
# objects first and the dependency objects last
define BIN_TARGET_template
$(1):         $(1).o $(LIB_TARGET_A) $$(LDLIBS_PROJECT:%.so=%.a)
	$$(CC_LINKER) $$(LDFLAGS) $$(filter %.o, $$^) $$(filter-out %.o, $$^) $$(LDLIBS) -o $$@
$(1).dynamic: $(1).o $(LIB_TARGET_SO) $$(LDLIBS_PROJECT)
	$$(CC_LINKER) $$(LDFLAGS) $$(filter %.o, $$^) $$(filter-out %.o, $$^) $$(LDLIBS) -o $$@
endef
$(foreach target,$(BIN_TARGET_ALL),$(eval $(call BIN_TARGET_template,$(target))))



include $(ROOT)/Makefile.install


#################### clean and all rules ##############################

clean_files := $(addprefix $(dir)/, *.a *.o *.so *.so.* *.d)
clean_files += $(BIN_TARGET_ALL) $(addsuffix .dynamic,$(BIN_TARGET_ALL)) $(EXTRACLEAN)

# This is done with an eval to immediately evaluate the files-to-clean list
define CLEAN_template
$(fulldir)/clean:
	rm -rf $(clean_files)
endef
$(eval $(CLEAN_template))


$(fulldir)/all: $(LIB_TARGET_A) $(BIN_TARGET_ALL)

clean_world: $(fulldir)/clean
all:         $(fulldir)/all

# clean_local just cleans out the current directory in a local build
ifndef TOPLEVEL_INCLUDED
clean_local: $(fulldir)/clean
.DEFAULT_GOAL := $(fulldir)/all
endif


.PHONY: clean_local clean_world all $(fulldir)/clean $(fulldir)/all

#######################################################################



# the header dependencies
-include $(dir)/*.d


# The recipes used to build targets are evaluated deferred (when needed), so by
# default, the current values of CFLAGS, etc will NOT be used when the recipe is
# evaluated. Here I save these variables on a per-target basis. This makes
# current variables "persist"
$(dir)/%.o: CXXFLAGS := -I$(dir) $(CXXFLAGS)
$(dir)/%.o: CFLAGS   := -I$(dir) $(CFLAGS)

$(BIN_TARGET_ALL) $(addsuffix .dynamic,$(BIN_TARGET_ALL)): LDFLAGS := $(LDFLAGS)
$(BIN_TARGET_ALL) $(addsuffix .dynamic,$(BIN_TARGET_ALL)): LDLIBS  := $(LDLIBS)
$(LIB_TARGET_SO):  LDFLAGS := $(LDFLAGS)
$(LIB_TARGET_SO):  LDLIBS  := $(LDLIBS)





ifndef TOPLEVEL_INCLUDED

# top-level makefile not yet included. This simply means that we're doing a make
# that originated in the middle of our tree. I mark this file as included, and
# include the top-level Makefile to get the others
$(fulldir)/INCLUDED := 1
include $(ROOT)/Makefile

endif
